########################
#file: zbw_rig.py
#author: zeth willie
#contact: zeth@catbuks.com, www.williework.blogspot.com
#date modified: 09/23/12
#
#notes: helper scripts for rigging
########################

import maya.cmds as cmds
import maya.mel as mel
import maya.OpenMaya as om

def getTwoSelection(*args):
    """gets two objects (only first 2) from selection and returns them in selected order as a list"""
    sel = cmds.ls(sl=True)
    if sel:
        objs = sel[:1]
    else:
        objs = []
    return objs


def jointFromList(xformList=[], orient="xyz", secAxis="zup", strip="", suffix="", *args):
    """
    uses the xformlist arg (a list of transforms in scene) to create a joint chain in order.
    Arguments: xformList (a list), orient ("xyz", etc), secAxis ("xup", "zdown", etc), strip (string to strip off), suffix (string to add to the joints)
    """
    jointList = []

    #if no list is provided, get the list from selection order
    if not xformList:
        sel = getSelection()

        if sel:
            xformList = sel
        #if no list && no selection then throw error
        else:
            cmds.error("you must provide a list of transforms or have the transforms selected in order")

    #clear selection
    cmds.select(cl=True)
    #for each thing in the list create a joint at that location (they'll be parented to the previous)
    for xform in xformList:
        xformPos = cmds.xform(xform, q=True, ws=True, t=True)
        jointName = "%s%s"%(xform.rstrip(strip), suffix)
        thisJoint = cmds.joint(n=jointName, p=xformPos)
        jointList.append(thisJoint)

    #now orient the joint chain based on args and return a list of the joints
    cmds.joint(jointList[0], e=True, ch=True, oj=orient, sao=secAxis)
    return(jointList)


def follicle(surface="none", folName="none", u=0.5, v=0.5, *args):
    """
    creates a follicle on a surface based on the uv input.
    Args are: surface, folName, u, v
    """
#------------do a bit more checking here to make sure the shapes, numbers etc work out
    if surface=="none":
        #decide if surface is polymesh or nurbsSurface
        surfaceXform = cmds.ls(sl=True, dag=True, type="transform")[0]
        surfaceShape = cmds.listRelatives(surfaceXform, shapes=True)[0]
    else:
        surfaceXform = surface
        surfaceShape = cmds.listRelatives(surfaceXform, shapes=True)[0]

    if folName == "none":
        folShapeName = "myFollicleShape"
        folXformName = "myFollicle"
    else:
        folShapeName = "%sShape"%folName
        folXformName = folName

#------------test if follicle exists
    #create the follicle
    folShape = cmds.createNode("follicle", n=folShapeName)
    folXform = cmds.listRelatives(folShape, p=True, type="transform")[0]
    cmds.rename(folXform, folXformName)

    #connect up the follicle!
    #connect the matrix of the surface to the matrix of the follicle
    cmds.connectAttr("%s.worldMatrix[0]"%surfaceShape, "%s.inputWorldMatrix"%folShape)

    #check for surface type, poly or nurbs and connect the matrix into the follicle
    if (cmds.nodeType(surfaceShape)=="nurbsSurface"):
        cmds.connectAttr("%s.local"%surfaceShape, "%s.inputSurface"%folShape)
    elif (cmds.nodeType(surfaceShape)=="mesh"):
        cmds.connectAttr("%s.outMesh"%surfaceShape, "%s.inputMesh"%folShape)
    else:
        cmds.warning("not the right kind of selection. Need a poly or nurbs surface")

    #connect the transl, rots from shape to transform of follicle
    cmds.connectAttr("%s.outTranslate"%folShape, "%s.translate"%folXform)
    cmds.connectAttr("%s.outRotate"%folShape, "%s.rotate"%folXform)

    cmds.setAttr("%s.parameterU"%folShape, u)
    cmds.setAttr("%s.parameterV"%folShape, v)

    cmds.setAttr("%s.translate"%folXform, l=True)
    cmds.setAttr("%s.rotate"%folXform, l=True)

    return(folXform, folShape)


def axisToVector(axis="+x"):
    """
    takes an arg ("+x", "-x", "+y", "-y", "+z", "-z") and converts it to a vector (ex. (1,0,0))
    """
    axisDict = {"+x":(1,0,0), "-x":(-1,0,0), "+y":(0,1,0), "-y":(0,-1,0), "+z":(0,0,1), "-z":(0,0,-1)}
    if axis in axisDict.keys():
        return(axisDict[axis])
    else:
        cmds.error("you need to enter an axis (i.e. '+x' or '-x'")


def fkChain(ctrlType="circle", color="red", axis="x", *args):
    """
    puts a correctly oriented control onto each joint of selected chain. Will name the controls after the joint names and parent them according to the joint order
    Select the top joint of a chain and call fkChain(ARGS)
    Arguments: ctrlType ("sphere", "circle", "cube", etc), color ("red", "darkRed",etc. See zbw_rig.createControl for full list), axis ("x", "y", "x")
    """

    #get the selected joint's chain of joints
    sel = cmds.ls(sl=True, type="joint")

    #initialize lists
    ctrlList = []
    groupList = []

    #for now just do one chain
    if len(sel) != 1:
        cmds.error("please select only the top level joint of one chain")
    else:
        #get the hierarchy of just joints
        allChain = cmds.select(sel[0], hi=True)
        chain = cmds.ls(sl=True, type="joint")
        chainSize = len(chain)

        for jnt in chain:
            #get the rot order
            rotOrder = cmds.getAttr("%s.rotateOrder"%jnt)

            #control name
            ctrlName =  jnt + "_CTRL"

            #create control
            ctrl = createControl(ctrlName, ctrlType, axis, color)

            #snap that control to the joint (group orient)
            groupOrient(jnt, ctrl, "GRP")
            group = ctrl + "_GRP"

            #orient constrain the joint to the control
            cmds.orientConstraint(ctrl, jnt)

            #set rotation order for the control and group
            cmds.setAttr("%s.rotateOrder"%ctrl, rotOrder)
            cmds.setAttr("%s.rotateOrder"%group, rotOrder)

            #add the controls and groups to lists to keep their order
            ctrlList.append(ctrl)
            groupList.append(group)


        #parent up the groups and controls correctly
        for i in range(chainSize-1, 0, -1):
            cmds.parent(groupList[i], ctrlList[i-1])


def createControl(name="default",type="circle", axis="x", color="darkBlue", *args):
    """
    creates control namemed by first arg, at origin.
    shape is determined by second arg: "cube", "octagon", "sphere", "diamond", "barbell", "lollipop", "cross", "bentCross", "arrow", "bentArrow", "halfCircle", "splitCircle", "cylinder", "square", "circle", 
    third arg can be 'x',, 'y', , 'z'  and is the axis along which the control lies.
    The colors are: 'lightBlue', 'darkGreen', 'lightPurple', 'yellow', 'darkPurple', 'pink', 'blue', 'purple', 'lightGreen', 'black', 'orange', 'white', 'darkYellow', 'brown', 'lightYellow', 'darkBlue', 'royalBlue', 'darkBrown', 'lightRed', 'medBlue', 'lightBrown', 'darkRed', 'yellowGreen', 'medGreen', 'green', 'red'
    Arguments: name, type, axis, color
    """
    colors = {}
    colors["red"]=13
    colors["blue"]=6
    colors["green"]=14
    colors["darkRed"]=4
    colors["lightRed"]=31
    colors["darkBlue"]=5
    colors["medBlue"]=15
    colors["lightBlue"]=18
    colors["royalBlue"]=29
    colors["darkGreen"]=7
    colors["medGreen"]=27
    colors["lightGreen"]=19
    colors["yellowGreen"]=26
    colors["yellow"]=17
    colors["darkYellow"]=21
    colors["lightYellow"]=22
    colors["purple"]=30
    colors["lightPurple"]=9
    colors["darkPurple"]=8
    colors["black"]=1
    colors["white"]=16
    colors["brown"]=10
    colors["darkBrown"]=11
    colors["lightBrown"]=24
    colors["pink"]=20
    colors["orange"] =12

    #deal with axis, x is default
    if axis == "x":
        rot = (0, 0, 0)
    elif axis == "y":
        rot = (0, 0, 90)
    elif axis =="z":
        rot = (0, 90, 0)
    else:
        cmds.warning('createControl: you entered an incorrect axis. Must be x, y or z')

    #-------------------------do this from dictionary, that way it's easier to control the flow to error or return
    if type == "star":
        ctrl = cmds.curve(n=name, d=1, p=[[7.409188411095804e-18, 0.29212280897151877, -0.12100122935453195], [1.4894014034610283e-32, 1.0260340642089774, -2.432377081290716e-16], [-7.409188411095782e-18, 0.29212280897151877, 0.12100122935452534], [-4.4425020590284054e-17, 0.7255156445305614, 0.7255156445305615], [-1.7887363148245247e-17, 0.12100122935452534, 0.2921228089715189], [-6.282646662748371e-17, -4.732847409704354e-17, 1.0260340642089776], [-1.7887363148245247e-17, -0.12100122935452984, 0.29212280897151444], [-4.4425020590284054e-17, -0.7255156445305617, 0.7255156445305615], [-7.409188411095782e-18, -0.29212280897151877, 0.12100122935452529], [4.747775441350691e-33, -1.0260340642089774, -7.753705712792092e-17], [7.409188411095804e-18, -0.29212280897151877, -0.12100122935453195], [4.442502059028405e-17, -0.7255156445305612, -0.7255156445305614], [1.788736314824529e-17, -0.12100122935452978, -0.2921228089715181], [6.282646662748368e-17, 1.7626752847979251e-16, -1.0260340642089771], [1.788736314824529e-17, 0.1210012293545254, -0.29212280897151865], [4.442502059028403e-17, 0.7255156445305616, -0.7255156445305612]])

        cmds.closeCurve(ctrl, ps=0, rpo=1, bb=0.5, bki=0, p=0.1)

    elif type == "box":
        ctrl = cmds.curve(n=name, d=1, p=[[-0.989623460780981, 1.0031016006564133, 1.0031016006564133], [-0.989623460780981, 1.0031016006564133, -1.0031016006564133], [-0.989623460780981, -1.0031016006564133, -1.0031016006564133], [-0.989623460780981, -1.0031016006564133, 1.0031016006564133], [-0.989623460780981, 1.0031016006564133, 1.0031016006564133], [0.989623460780981, 1.0031016006564133, 1.0031016006564133], [0.989623460780981, -1.0031016006564133, 1.0031016006564133], [-0.989623460780981, -1.0031016006564133, 1.0031016006564133], [0.989623460780981, -1.0031016006564133, 1.0031016006564133], [0.989623460780981, -1.0031016006564133, -1.0031016006564133], [0.989623460780981, 1.0031016006564133, -1.0031016006564133], [-0.989623460780981, 1.0031016006564133, -1.0031016006564133], [-0.989623460780981, -1.0031016006564133, -1.0031016006564133], [0.989623460780981, -1.0031016006564133, -1.0031016006564133], [0.989623460780981, 1.0031016006564133, -1.0031016006564133], [0.989623460780981, 1.0031016006564133, 1.0031016006564133]])

    elif type == "cube":
        ctrl = cmds.curve(n=name, d=1, p=[[-0.989623460780981, 1.0031016006564133, 1.0031016006564133], [-0.989623460780981, 1.0031016006564133, -1.0031016006564133], [-0.989623460780981, -1.0031016006564133, -1.0031016006564133], [-0.989623460780981, -1.0031016006564133, 1.0031016006564133], [-0.989623460780981, 1.0031016006564133, 1.0031016006564133], [0.989623460780981, 1.0031016006564133, 1.0031016006564133], [0.989623460780981, -1.0031016006564133, 1.0031016006564133], [-0.989623460780981, -1.0031016006564133, 1.0031016006564133], [0.989623460780981, -1.0031016006564133, 1.0031016006564133], [0.989623460780981, -1.0031016006564133, -1.0031016006564133], [0.989623460780981, 1.0031016006564133, -1.0031016006564133], [-0.989623460780981, 1.0031016006564133, -1.0031016006564133], [-0.989623460780981, -1.0031016006564133, -1.0031016006564133], [0.989623460780981, -1.0031016006564133, -1.0031016006564133], [0.989623460780981, 1.0031016006564133, -1.0031016006564133], [0.989623460780981, 1.0031016006564133, 1.0031016006564133]])

    elif type == "octagon":
        ctrl = cmds.curve(n=name, d=1, p=[[-7.4559598726027055e-17, 0.70710670948028576, 0.70710670948028564], [5.5511098291698525e-17, 0.99999988079071067, 0.0], [-7.4559598726027055e-17, 0.70710670948028576, -0.70710670948028564], [-3.8857805861880489e-16, 1.7256332301709633e-31, -0.99999988079071045], [-7.0259651851158272e-16, -0.70710670948028576, -0.70710670948028564], [-8.326672684688675e-16, -1.0000000000000002, 0.0], [-7.0259654498136232e-16, -0.70710676908493053, 0.70710676908493042], [-3.8857805861880489e-16, 1.7256332301709633e-31, 0.99999994039535522], [-7.4559598726027055e-17, 0.70710670948028576, 0.70710670948028564]])


    elif type == "square":
        ctrl = cmds.curve(n=name, d=1, p=[[8.326672684688674e-17, 0.9945171827003073, 0.9945171827003073], [8.326672684688674e-17, -0.9945171827003073, 0.9945171827003073], [-8.326672684688674e-17, -0.9945171827003073, -0.9945171827003073], [-8.326672684688674e-17, 0.9945171827003073, -0.9945171827003073], [8.326672684688674e-17, 0.9945171827003073, 0.9945171827003073]])   

    elif type == "circle":
        ctrl = cmds.curve(n=name, d=3, p=[[0.0, 0.7836116248912253, -0.7836116248912238], [-6.785732323110913e-17, -1.2643170607829324e-16, -1.108194187554388], [-1.1102230246251565e-16, -0.7836116248912242, -0.7836116248912243], [-2.220446049250313e-16, -1.1081941875543877, -3.21126950723723e-16], [0.0, -0.7836116248912244, 0.783611624891224], [6.785732323110906e-17, -3.3392053635905195e-16, 1.1081941875543881], [-1.1102230246251565e-16, 0.7836116248912238, 0.7836116248912244], [2.220446049250313e-16, 1.1081941875543877, 5.952132599280585e-16]])
            
        cmds.closeCurve(ctrl, ps=0, rpo=1, bb=0.5, bki=0, p=0.1)

    elif type == "lollipop":
        ctrl = cmds.curve(n=name, d=3, p=[[3.049027774309277, -1.2212453270876722e-15, 0.0], [3.0410738048588266, 0.039987505139348234, 0.0], [3.0331198354083746, 0.07997501027869791, 0.0], [3.025165865957925, 0.11996251541804748, 0.0], [3.002514712257412, 0.15386239173167593, 0.0], [2.9798635585569024, 0.18776226804530438, 0.0], [2.9572124048563926, 0.22166214435893306, 0.0], [2.923312528542762, 0.24431329805944269, 0.0], [2.889412652229132, 0.26696445175995287, 0.0], [2.855512775915506, 0.28961560546046283, 0.0], [2.815525270776157, 0.2975695749109146, 0.0], [2.7755377656368068, 0.3055235443613664, 0.0], [2.735550260497454, 0.3134775138118183, 0.0], [2.695562755358107, 0.3055235443613662, 0.0], [2.655575250218759, 0.2975695749109144, 0.0], [2.615587745079408, 0.2896156054604624, 0.0], [2.581687868765782, 0.2669644517599532, 0.0], [2.54778799245215, 0.24431329805944335, 0.0], [2.5138881161385247, 0.22166214435893317, 0.0], [2.491236962438015, 0.18776226804530505, 0.0], [2.4685858087375023, 0.15386239173167582, 0.0], [2.445934655036992, 0.11996251541804748, 0.0], [2.4379806855865427, 0.07997501027869836, 0.0], [2.43002671613609, 0.03998750513934857, 0.0], [2.4220727466856347, -9.992007221626409e-16, 0.0], [2.4300267161360893, -0.039987505139350454, 0.0], [2.4379806855865422, -0.07997501027870013, 0.0], [2.4459346550369916, -0.11996251541804948, 0.0], [2.4685858087375023, -0.1538623917316781, 0.0], [2.4912369624380144, -0.18776226804530644, 0.0], [2.5138881161385243, -0.2216621443589351, 0.0], [2.54778799245215, -0.24431329805944452, 0.0], [2.581687868765782, -0.2669644517599549, 0.0], [2.6155877450794085, -0.2896156054604649, 0.0], [2.6555752502187593, -0.29756957491091657, 0.0], [2.6955627553581074, -0.30552354436136836, 0.0], [2.735550260497455, -0.3134775138118204, 0.0], [2.7755377656368068, -0.30552354436136814, 0.0], [2.815525270776156, -0.2975695749109166, 0.0], [2.8555127759155052, -0.28961560546046444, 0.0], [2.889412652229132, -0.26696445175995454, 0.0], [2.9233125285427612, -0.24431329805944524, 0.0], [2.957212404856393, -0.22166214435893516, 0.0], [2.979863558556901, -0.18776226804530716, 0.0], [3.0025147122574127, -0.15386239173167793, 0.0], [3.0251658659579244, -0.11996251541804959, 0.0], [3.0331198354083746, -0.07997501027870013, 0.0], [3.0410738048588266, -0.039987505139350454, 0.0], [3.049027774309277, -1.2212453270876722e-15, 0.0], [3.041073804858827, -1.2212453270876722e-15, 0.03998750513934949], [3.0331198354083746, -9.992007221626409e-16, 0.07997501027869898], [3.0251658659579244, -1.5543122344752192e-15, 0.11996251541804842], [3.0025147122574123, -1.3322676295501878e-15, 0.153862391731677], [2.979863558556902, -1.1102230246251565e-15, 0.18776226804530566], [2.9572124048563935, -1.4432899320127035e-15, 0.22166214435893408], [2.9233125285427617, -1.1102230246251565e-15, 0.24431329805944402], [2.8894126522291317, -1.1102230246251565e-15, 0.26696445175995387], [2.8555127759155066, -8.881784197001252e-16, 0.2896156054604636], [2.8155252707761567, -8.881784197001252e-16, 0.2975695749109156], [2.7755377656368063, -9.992007221626409e-16, 0.3055235443613673], [2.7355502604974546, -6.661338147750939e-16, 0.31347751381181904], [2.695562755358108, -1.1102230246251565e-15, 0.3055235443613673], [2.6555752502187593, -6.661338147750939e-16, 0.2975695749109156], [2.6155877450794076, -7.771561172376096e-16, 0.2896156054604636], [2.581687868765782, -1.1102230246251565e-15, 0.26696445175995387], [2.5477879924521503, -5.551115123125783e-16, 0.24431329805944402], [2.5138881161385243, -1.1102230246251565e-15, 0.22166214435893408], [2.491236962438015, -8.881784197001252e-16, 0.18776226804530566], [2.468585808737502, -1.1102230246251565e-15, 0.153862391731677], [2.445934655036992, -9.992007221626409e-16, 0.11996251541804842], [2.4379806855865422, -9.992007221626409e-16, 0.07997501027869898], [2.43002671613609, -1.1102230246251565e-15, 0.03998750513934949], [2.4220727466856347, -9.992007221626409e-16, 0.0], [2.43002671613609, -1.1102230246251565e-15, -0.03998750513934949], [2.4379806855865422, -9.992007221626409e-16, -0.07997501027869898], [2.445934655036992, -9.992007221626409e-16, -0.11996251541804842], [2.468585808737502, -1.1102230246251565e-15, -0.153862391731677], [2.491236962438015, -8.881784197001252e-16, -0.18776226804530566], [2.5138881161385243, -1.1102230246251565e-15, -0.22166214435893408], [2.5477879924521503, -5.551115123125783e-16, -0.24431329805944402], [2.581687868765782, -1.1102230246251565e-15, -0.26696445175995387], [2.6155877450794076, -7.771561172376096e-16, -0.2896156054604636], [2.6555752502187593, -6.661338147750939e-16, -0.2975695749109156], [2.695562755358108, -1.1102230246251565e-15, -0.3055235443613673], [2.7355502604974546, -6.661338147750939e-16, -0.31347751381181904], [2.7755377656368063, -9.992007221626409e-16, -0.3055235443613673], [2.8155252707761567, -8.881784197001252e-16, -0.2975695749109156], [2.8555127759155066, -8.881784197001252e-16, -0.2896156054604636], [2.8894126522291317, -1.1102230246251565e-15, -0.26696445175995387], [2.9233125285427617, -1.1102230246251565e-15, -0.24431329805944402], [2.9572124048563935, -1.4432899320127035e-15, -0.22166214435893408], [2.9798635585569, -1.3322676295501878e-15, -0.18776226804530566], [3.0025147122574123, -1.3322676295501878e-15, -0.153862391731677], [3.0251658659579244, -1.5543122344752192e-15, -0.11996251541804842], [3.0331198354083746, -9.992007221626409e-16, -0.07997501027869898], [3.041073804858827, -1.2212453270876722e-15, -0.03998750513934949], [3.049027774309277, -1.2212453270876722e-15, 0.0], [3.0410738048588266, 0.039987505139348234, 0.0], [3.0331198354083746, 0.07997501027869791, 0.0], [3.025165865957925, 0.11996251541804748, 0.0], [3.002514712257412, 0.15386239173167593, 0.0], [2.9798635585569024, 0.18776226804530438, 0.0], [2.9572124048563926, 0.22166214435893306, 0.0], [2.923312528542762, 0.24431329805944269, 0.0], [2.889412652229132, 0.26696445175995287, 0.0], [2.855512775915506, 0.28961560546046283, 0.0], [2.815525270776157, 0.2975695749109146, 0.0], [2.7755377656368068, 0.3055235443613664, 0.0], [2.735550260497454, 0.3134775138118183, 0.0], [2.735550260497454, 0.30552354436136675, 0.03998750513934949], [2.7355502604974546, 0.2975695749109144, 0.07997501027869898], [2.7355502604974546, 0.2896156054604627, 0.11996251541804842], [2.735550260497454, 0.2669644517599531, 0.153862391731677], [2.7355502604974546, 0.24431329805944335, 0.18776226804530566], [2.7355502604974546, 0.22166214435893317, 0.22166214435893408], [2.735550260497455, 0.1877622680453046, 0.24431329805944402], [2.735550260497454, 0.15386239173167593, 0.26696445175995387], [2.735550260497455, 0.11996251541804748, 0.2896156054604636], [2.7355502604974546, 0.07997501027869824, 0.2975695749109156], [2.735550260497454, 0.03998750513934857, 0.3055235443613673], [2.7355502604974546, -6.661338147750939e-16, 0.31347751381181904], [2.7355502604974546, -0.039987505139350676, 0.3055235443613673], [2.735550260497454, -0.07997501027870046, 0.2975695749109156], [2.735550260497454, -0.11996251541804981, 0.2896156054604636], [2.735550260497454, -0.15386239173167793, 0.26696445175995387], [2.7355502604974546, -0.1877622680453066, 0.24431329805944402], [2.7355502604974546, -0.22166214435893505, 0.22166214435893408], [2.735550260497454, -0.24431329805944485, 0.18776226804530566], [2.735550260497455, -0.2669644517599546, 0.153862391731677], [2.735550260497454, -0.28961560546046466, 0.11996251541804842], [2.7355502604974546, -0.29756957491091673, 0.07997501027869898], [2.7355502604974546, -0.30552354436136814, 0.03998750513934949], [2.735550260497455, -0.3134775138118204, 0.0], [2.7355502604974546, -0.30552354436136814, -0.03998750513934949], [2.7355502604974546, -0.29756957491091673, -0.07997501027869898], [2.735550260497454, -0.28961560546046466, -0.11996251541804842], [2.735550260497455, -0.2669644517599546, -0.153862391731677], [2.735550260497454, -0.24431329805944485, -0.18776226804530566], [2.7355502604974546, -0.22166214435893505, -0.22166214435893408], [2.7355502604974546, -0.1877622680453066, -0.24431329805944402], [2.735550260497454, -0.15386239173167793, -0.26696445175995387], [2.735550260497454, -0.11996251541804981, -0.2896156054604636], [2.735550260497454, -0.07997501027870046, -0.2975695749109156], [2.7355502604974546, -0.039987505139350676, -0.3055235443613673], [2.7355502604974546, -6.661338147750939e-16, -0.31347751381181904], [2.735550260497454, 0.03998750513934857, -0.3055235443613673], [2.7355502604974546, 0.07997501027869824, -0.2975695749109156], [2.735550260497455, 0.11996251541804748, -0.2896156054604636], [2.735550260497454, 0.15386239173167593, -0.26696445175995387], [2.735550260497455, 0.1877622680453046, -0.24431329805944402], [2.7355502604974546, 0.22166214435893317, -0.22166214435893408], [2.7355502604974546, 0.24431329805944335, -0.18776226804530566], [2.735550260497454, 0.2669644517599531, -0.153862391731677], [2.7355502604974546, 0.2896156054604627, -0.11996251541804842], [2.7355502604974546, 0.2967741779658696, -0.08397376079263402], [2.7355502604974546, 0.3039327504712762, -0.04798500616721953], [2.735550260497454, 0.3110913229766823, -0.0005188496396816394], [2.5074085002467696, 0.25861894889475023, -3.329536000368783e-05], [2.448198148030916, 0.12339224787059111, 0.001267427874337896], [2.4269096562757526, 0.03644505323376124, -0.00021038739364469887], [2.423864171539766, -0.0015188811856942097, -0.0007377036525121326], [2.3649838303273656, 0.0017771428252882915, 0.0], [1.9810435663376074, 0.0017771428252886246, 0.0], [1.2144291324888028, 0.0017771428252886246, 0.0], [0.4218639951594623, 0.00177714282528868, 0.0], [0.004724449196651652, 0.0017771428252887878, 0.0]])

    elif type == "barbell":
        ctrl = cmds.curve(n=name, d=3, p=[[6.01782054027684e-16, -0.5775251028532469, -0.906508437755886], [6.192062058311844e-16, 8.518393017971479e-16, -1.661011590594498], [5.462709027964262e-16, 0.5775251028532461, -0.9065084377558866], [5.601486906042406e-16, 0.2981402840890996, -0.6739732255141788], [5.462709027964262e-16, 0.1403364581427794, -2.7549060854235934e-16], [5.323931149886117e-16, 0.2981402840890998, 0.6739732255141784], [5.462709027964262e-16, 0.5775251028532469, 0.9065084377558864], [4.910168187939721e-16, 1.215829108822801e-15, 1.6610115905944978], [5.185153271807972e-16, -0.5775251028532444, 0.9065084377558871], [5.462709027964262e-16, -0.2981402840890981, 0.6739732255141794], [5.323931149886117e-16, -0.14033645814277831, 8.765144605053573e-16], [6.156598418354984e-16, -0.29814028408909865, -0.6739732255141776]])
        cmds.closeCurve(name, ch=False, ps=False, rpo=True, bki=True)

    elif type == "sphere":
        ctrl = cmds.curve(n=name, d=1, p=[[0.0, 1.0, 0.0], [-0.382683, 0.92388000000000003, 0.0], [-0.70710700000000004, 0.70710700000000004, 0.0], [-0.92388000000000003, 0.382683, 0.0], [-1.0, 0.0, 0.0], [-0.92388000000000003, -0.382683, 0.0], [-0.70710700000000004, -0.70710700000000004, 0.0], [-0.382683, -0.92388000000000003, 0.0], [0.0, -1.0, 0.0], [0.382683, -0.92388000000000003, 0.0], [0.70710700000000004, -0.70710700000000004, 0.0], [0.92388000000000003, -0.382683, 0.0], [1.0, 0.0, 0.0], [0.92388000000000003, 0.382683, 0.0], [0.70710700000000004, 0.70710700000000004, 0.0], [0.382683, 0.92388000000000003, 0.0], [0.0, 1.0, 0.0], [0.0, 0.92388000000000003, 0.382683], [0.0, 0.70710700000000004, 0.70710700000000004], [0.0, 0.382683, 0.92388000000000003], [0.0, 0.0, 1.0], [0.0, -0.382683, 0.92388000000000003], [0.0, -0.70710700000000004, 0.70710700000000004], [0.0, -0.92388000000000003, 0.382683], [0.0, -1.0, 0.0], [0.0, -0.92388000000000003, -0.382683], [0.0, -0.70710700000000004, -0.70710700000000004], [0.0, -0.382683, -0.92388000000000003], [0.0, 0.0, -1.0], [0.0, 0.382683, -0.92388000000000003], [0.0, 0.70710700000000004, -0.70710700000000004], [0.0, 0.92388000000000003, -0.382683], [0.0, 1.0, 0.0], [-0.382683, 0.92388000000000003, 0.0], [-0.70710700000000004, 0.70710700000000004, 0.0], [-0.92388000000000003, 0.382683, 0.0], [-1.0, 0.0, 0.0], [-0.92388000000000003, 0.0, 0.382683], [-0.70710700000000004, 0.0, 0.70710700000000004], [-0.382683, 0.0, 0.92388000000000003], [0.0, 0.0, 1.0], [0.382683, 0.0, 0.92388000000000003], [0.70710700000000004, 0.0, 0.70710700000000004], [0.92388000000000003, 0.0, 0.382683], [1.0, 0.0, 0.0], [0.92388000000000003, 0.0, -0.382683], [0.70710700000000004, 0.0, -0.70710700000000004], [0.382683, 0.0, -0.92388000000000003], [0.0, 0.0, -1.0], [-0.382683, 0.0, -0.92388000000000003], [-0.70710700000000004, 0.0, -0.70710700000000004], [-0.92388000000000003, 0.0, -0.382683], [-1.0, 0.0, 0.0]])

    elif type == "arrowCross":
        ctrl = cmds.curve(n=name, d=1, p=[[-1.8356595506906512e-16, -0.8267075668469511, -0.27556918894898336], [-6.11886516896884e-17, -0.2755691889489838, -0.27556918894898336], [-6.11886516896884e-17, -0.2755691889489838, -0.8267075668469501], [-1.223773033793768e-16, -0.5511383778979676, -0.8267075668469501], [0.0, 0.0, -1.3778459447449163], [1.223773033793768e-16, 0.5511383778979676, -0.8267075668469501], [6.11886516896884e-17, 0.2755691889489838, -0.8267075668469501], [6.11886516896884e-17, 0.2755691889489838, -0.27556918894898336], [1.8356595506906512e-16, 0.8267075668469511, -0.27556918894898336], [1.8356595506906512e-16, 0.8267075668469511, -0.5511383778979667], [3.059432584484418e-16, 1.3778459447449183, 0.0], [1.8356595506906512e-16, 0.8267075668469511, 0.5511383778979667], [1.8356595506906512e-16, 0.8267075668469511, 0.27556918894898336], [6.11886516896884e-17, 0.2755691889489838, 0.27556918894898336], [6.11886516896884e-17, 0.2755691889489838, 0.8267075668469501], [1.223773033793768e-16, 0.5511383778979676, 0.8267075668469501], [0.0, 0.0, 1.3778459447449163], [-1.223773033793768e-16, -0.5511383778979676, 0.8267075668469501], [-6.11886516896884e-17, -0.2755691889489838, 0.8267075668469501], [-6.11886516896884e-17, -0.2755691889489838, 0.27556918894898336], [-1.8356595506906512e-16, -0.8267075668469511, 0.27556918894898336], [-1.8356595506906512e-16, -0.8267075668469511, 0.5511383778979667], [-3.059432584484418e-16, -1.3778459447449183, 0.0], [-1.8356595506906512e-16, -0.8267075668469511, -0.5511383778979667], [-1.8356595506906512e-16, -0.8267075668469511, -0.27556918894898336]])

    elif type=="diamond":
        ctrl = cmds.curve(n=name, d=1, p=[[3.1401849173675503e-16, 0.70710678118654768, 1.1102230246251565e-16], [4.9303806576313238e-32, 1.1102230246251568e-16, -0.70710678118654757], [-3.1401849173675503e-16, -0.70710678118654768, -1.1102230246251565e-16], [-4.9303806576313238e-32, -1.1102230246251568e-16, 0.70710678118654757], [3.1401849173675503e-16, 0.70710678118654768, 1.1102230246251565e-16]])

    elif type == "cross":
        ctrl = cmds.curve(n=name, d=1, p=[[0.0, 0.3860674774797851, -0.3860674774797847], [0.0, 0.3860674774797851, -1.5442699099191388], [0.0, -0.3860674774797851, -1.5442699099191388], [0.0, -0.3860674774797851, -0.3860674774797847], [0.0, -1.5442699099191404, -0.3860674774797847], [0.0, -1.5442699099191404, 0.3860674774797847], [0.0, -0.3860674774797851, 0.3860674774797847], [0.0, -0.3860674774797851, 1.5442699099191388], [0.0, 0.3860674774797851, 1.5442699099191388], [0.0, 0.3860674774797851, 0.3860674774797847], [0.0, 1.5442699099191404, 0.3860674774797847], [0.0, 1.5442699099191404, -0.3860674774797847], [0.0, 0.3860674774797851, -0.3860674774797847]])
    
    elif type=="bentCross":
        ctrl = cmds.curve(n=name, d=1, p=[[0.8274786828331014, -0.3860674774797851, 0.38606747747978465], [0.8274786828331014, -0.3860674774797851, 0.38606747747978465], [0.7808518150353615, -0.6066405549013819, 0.38606747747978465], [0.6071567532289701, -0.9451783209762857, 0.38606747747978465], [0.3763450724097211, -1.2244719779880804, 0.38606747747978465], [0.0537125369803636, -1.5442699099191395, 0.38606747747978465], [0.09041309204078879, -1.54426990991914, 0.20428365981828614], [0.10335783335851317, -1.544269909919139, -0.06654655304163733], [0.0537125369803636, -1.5442699099191395, -0.38606747747978465], [0.24416235026919691, -1.359887084418042, -0.38606747747978465], [0.5640541381623192, -1.004422430039393, -0.38606747747978465], [0.7384291276475636, -0.7166653288757251, -0.38606747747978465], [0.8274786828331014, -0.3860674774797851, -0.38606747747978465], [0.8362644817044962, -0.13268768239651652, -0.38606747747978465], [0.836420869378913, 0.1550694187671512, -0.38606747747978465], [0.8274786828331016, 0.386067477479785, -0.38606747747978465], [0.7640934959418438, 0.6544126237276336, -0.38606747747978465], [0.5726724922411628, 0.9929503898025378, -0.38606747747978465], [0.36323278075594756, 1.238390270206842, -0.38606747747978465], [0.053712536980363434, 1.54426990991914, -0.38606747747978465], [0.09695153179139865, 1.5442699099191395, -0.15118099456036274], [0.09378004807796125, 1.5442699099191395, 0.17889332736266814], [0.053712536980363434, 1.54426990991914, 0.38606747747978465], [0.2978042265334492, 1.3060978234218237, 0.38606747747978465], [0.5912860093310957, 0.9675600573469202, 0.38606747747978465], [0.7541522993123086, 0.6798029561832517, 0.38606747747978465], [0.8274786828331016, 0.386067477479785, 0.38606747747978465], [0.8362397401401597, 0.1296790863115338, 0.38606747747978465], [0.8364326269784885, -0.20885867976336997, 0.38606747747978465], [0.8274786828331014, -0.3860674774797851, 0.38606747747978465], [0.8364560049861686, -0.38606747747978526, 0.1619664390589226], [0.8365004708613251, -0.3860674774797849, -0.19349821531972625], [0.8274786828331014, -0.3860674774797851, -0.38606747747978465], [0.7775424419073371, -0.3860674774797851, -0.6166704229133558], [0.6510158841904213, -0.3860674774797851, -0.8790371916214059], [0.39066934126631003, -0.38606747747978504, -1.2091115135444368], [0.053712536980364434, -0.386067477479785, -1.5442699099191386], [0.09525870757622251, -0.16654145900400702, -1.5442699099191386], [0.10111365899767688, 0.10428875385591588, -1.5442699099191386], [0.05371253698036451, 0.38606747747978476, -1.5442699099191386], [0.35083910745370783, 0.386067477479785, -1.2514287343037995], [0.6402321360475454, 0.38606747747978476, -0.8959640799251507], [0.7803422395344458, 0.38606747747978487, -0.6082069787614832], [0.8274786828331016, 0.386067477479785, -0.38606747747978465], [0.8363979597053453, 0.3860674774797846, -0.15118099456036274], [0.8365066611928498, 0.38606747747978487, 0.17889332736266814], [0.8274786828331016, 0.386067477479785, 0.38606747747978465], [0.7614645207554611, 0.38606747747978465, 0.6613096440194054], [0.5924132741504969, 0.3860674774797851, 0.965993633486819], [0.31592777888748574, 0.38606747747978476, 1.287604511257977], [0.05371253698036451, 0.38606747747978476, 1.5442699099191386], [0.09358506649850806, 0.18045975122276922, 1.5442699099191386], [0.09796933434102197, -0.1411511265483891, 1.5442699099191386], [0.053712536980364434, -0.386067477479785, 1.5442699099191386], [0.307655584688856, -0.38606747747978487, 1.2960679554098502], [0.5801017811377607, -0.38606747747978504, 0.9829205217905641], [0.7708808023896162, -0.3860674774797852, 0.635919311563788], [0.8274786828331014, -0.3860674774797851, 0.38606747747978465]])

    elif type == "arrow":
        ctrl = cmds.curve(n=name, d=1, p=[[-1.3877787807814457e-17, -0.3320511730459853, 4.085081811240161], [1.3877787807814457e-17, 0.3320511730459853, 4.085081811240161], [1.3877787807814457e-17, 0.3320511730459853, 1.4286724268722804], [-5.551115123125783e-17, 0.82940130355245, 1.4286724268722804], [0.0, 0.0, -0.03941468189133124], [5.551115123125783e-17, -0.82940130355245, 1.4286724268722804], [-1.3877787807814457e-17, -0.3320511730459853, 1.4286724268722804], [-1.3877787807814457e-17, -0.3320511730459853, 4.085081811240161]])

    elif type == "bentArrow":
        ctrl = cmds.curve(n=name, d=1, p=[[-3.642919299551295e-16, 0.07714520952834365, 1.7421469815759187], [-2.498001805406602e-16, 0.3043343402351091, 1.7277538543978372], [-2.220446049250313e-16, 0.5278906569045598, 1.6848046227580475], [-8.326672684688674e-17, 0.8071191150064384, 1.587507493499599], [-1.1102230246251565e-16, 1.0666535304368314, 1.4458136320126154], [0.0, 1.3482917680751965, 1.216680181889537], [-1.6653345369377348e-16, 1.5782258782393308, 0.935695235943359], [5.551115123125783e-17, 1.7136822227908544, 0.6919757272125899], [1.1102230246251565e-16, 1.8098782456273892, 0.43026224761006543], [-1.6653345369377348e-16, 1.8732222243036842, 0.06421548326736613], [-1.1102230246251565e-16, 1.8600852246337547, -0.30703929792740153], [-1.6653345369377348e-16, 1.782183123872476, -0.6357544231538241], [1.6653345369377348e-16, 1.6442403235846081, -0.9441278245755171], [-1.6653345369377348e-16, 1.4825687166336698, -1.1830942737429422], [0.0, 1.2847981950408933, -1.393164483698346], [-4.440892098500626e-16, 1.3995023836900138, -1.5199713584804706], [-4.440892098500626e-16, 1.5427373374086277, -1.6783193408386454], [-2.7755575615628914e-16, 1.167500721163653, -1.7778314569883817], [2.7755575615628914e-17, 0.8288400682891588, -1.8014510246976516], [1.249000902703301e-16, 0.49170033456556966, -1.7601858662837695], [3.0531133177191805e-16, 0.271885017976391, -1.6934149528912896], [5.100087019371813e-16, 0.07714520952834367, -1.60161310354475], [4.3021142204224816e-16, 0.2671750390550334, -1.4724383744593847], [4.440892098500626e-16, 0.4175296210942235, -1.3285285245194984], [3.885780586188048e-16, 0.529101105398402, -1.1800828990636631], [3.608224830031759e-16, 0.6145347726588141, -1.014654082709085], [3.0531133177191805e-16, 0.6650685913251505, -0.8512095925636372], [3.608224830031759e-16, 0.682437730372658, -0.7272476683103402], [4.440892098500626e-16, 0.8095840009249512, -0.8678094158700487], [1.942890293094024e-16, 0.9403768727403921, -1.0124025254506397], [1.6653345369377348e-16, 1.096677616799007, -0.8432238511805955], [0.0, 1.220314466821743, -0.6488909519136365], [1.1102230246251565e-16, 1.289967364902085, -0.48814153011609995], [1.6653345369377348e-16, 1.337140514449174, -0.3194210607561526], [-5.551115123125783e-17, 1.3629370413073851, -0.006886349050293625], [-1.1102230246251565e-16, 1.3123699629032974, 0.30260739466787223], [-5.551115123125783e-17, 1.2286816082609129, 0.5162330520776699], [0.0, 1.108386494943658, 0.7116012887961971], [-1.6653345369377348e-16, 0.9553087436548093, 0.8825014475640204], [-1.942890293094024e-16, 0.7743146185490145, 1.0235006989226911], [-4.440892098500626e-16, 0.5878556380680062, 1.1230359867958644], [-5.273559366969494e-16, 0.3876181472910095, 1.1907055680073992], [-5.551115123125783e-16, 0.23354106691967916, 1.2191821652250647], [-6.591949208711867e-16, 0.07714520952834363, 1.228721508791549], [-5.342948306008566e-16, 0.07714520952834363, 1.4414649690436394], [-3.642919299551295e-16, 0.07714520952834365, 1.7421469815759187]])

    elif type == "halfCircle":
        ctrl = cmds.curve(n=name, d=1, p=[[-2.7755575615628914e-17, 4.8437241679061754e-08, 0.8400919472085637], [1.1102230246251565e-16, 5.959384395805263e-08, 1.0335912342837912], [2.7755575615628914e-17, 0.26722998718233276, 0.9974669556462239], [0.0, 0.5163555067066525, 0.894275806808919], [-2.7755575615628914e-17, 0.7308593616920411, 0.7308593707370429], [-1.6653345369377348e-16, 0.8942758118731857, 0.5163554898849724], [-1.942890293094024e-16, 0.9974669524653665, 0.2672300188450923], [-2.220446049250313e-16, 1.0335912369129387, 3.5859629426512516e-17], [-2.220446049250313e-16, 0.9974669524653665, -0.26723001884509223], [-1.942890293094024e-16, 0.8942758118731864, -0.5163554898849723], [-5.551115123125783e-17, 0.7308593616920411, -0.7308593707370421], [-1.942890293094024e-16, 0.5163555067066522, -0.8942758068089194], [0.0, 0.2672299871823323, -0.9974669556462237], [0.0, 5.959384350622128e-08, -1.0335912342837907], [-2.7755575615628914e-17, 4.8437241311818047e-08, -0.8400919472085634], [-1.6653345369377348e-16, 0.21720168751245922, -0.8107305182649762], [-1.6653345369377348e-16, 0.41968825652980724, -0.7268578515027716], [-1.942890293094024e-16, 0.5940347053397059, -0.5940347126913864], [-3.885780586188048e-16, 0.7268578556189536, -0.41968824285732503], [-1.6653345369377348e-16, 0.8107305156796093, -0.21720171324761323], [-1.6653345369377348e-16, 0.8400919493455073, 2.914632488342577e-17], [-1.8041124150158794e-16, 0.8107305156796093, 0.21720171324761323], [-2.0816681711721685e-16, 0.726857855618953, 0.41968824285732526], [-2.7755575615628914e-17, 0.5940347053397059, 0.5940347126913869], [-8.326672684688674e-17, 0.41968825652980735, 0.7268578515027712], [-5.551115123125783e-17, 0.21720168751245958, 0.8107305182649763], [-2.7755575615628914e-17, 4.8437241679061754e-08, 0.8400919472085637]])

    elif type == "splitCircle":
        ctrl = cmds.curve(n=name, d=1, p=[[7.253037477821285e-17, 1.074689453293533, 3.16613479828425e-17], [7.87654181931619e-17, 1.0461362549878175, 0.21122277819503865], [-1.3084821343715137e-16, 0.9645723667121134, 0.40813543920373496], [1.06106326666681e-16, 0.8354054536564309, 0.577682654905786], [1.9724268824507832e-16, 0.6658582583998096, 0.7068495568092826], [3.0660632213915455e-16, 0.4689455590682553, 0.7884134516020607], [4.159699560332314e-16, 0.25772285300386, 0.8169666453154578], [2.3369723287643667e-16, 0.2577228638533537, 1.0051394565869542], [3.0660632213915455e-16, 0.517596724322177, 0.9700095748745576], [5.1424509719642767e-17, 0.7598645387257423, 0.8696589799522008], [1.2433359898236044e-16, 0.9684637228947344, 0.7107409257907973], [1.06106326666681e-16, 1.1273817907770172, 0.5021417164671588], [-7.61663964901132e-17, 1.227732377681216, 0.25987394921339635], [1.0898491940957177e-16, 1.2628622650436863, 3.8189854665677087e-17], [-4.8825488016594077e-17, 1.227732377681216, -0.2598739492133965], [3.319723740396332e-17, 1.1273817907770178, -0.5021417164671585], [1.496996508828389e-17, 0.9684637228947344, -0.7107409257907967], [-2.1484579543074918e-17, 0.7598645387257421, -0.8696589799522013], [5.1424509719642767e-17, 0.5175967243221766, -0.9700095748745576], [1.6078814361371926e-16, 0.2577228638533531, -1.0051394565869536], [8.78790543510016e-17, 0.2577228530038597, -0.8169666453154578], [1.2433359898236044e-16, 0.46894555906825497, -0.7884134516020602], [1.496996508828389e-17, 0.6658582583998094, -0.706849556809283], [-5.793912417443386e-17, 0.8354054536564309, -0.5776826549057854], [1.496996508828389e-17, 0.9645723667121137, -0.4081354392037349], [2.4083601246123633e-17, 1.0461362549878175, -0.2112227781950388], [7.253037477821285e-17, 1.074689453293533, 3.16613479828425e-17], [-3.6833259115863677e-17, -1.0746894532935332, 3.16613479828425e-17], [-3.257307227395534e-18, -1.0461362549878177, 0.21122277819503857], [3.97742683717552e-16, -0.9645723667121137, 0.40813543920373513], [1.790154159293988e-16, -0.8354054536564309, 0.5776826549057856], [2.7015177750779605e-16, -0.6658582583998096, 0.7068495568092825], [1.6078814361371926e-16, -0.4689455590682553, 0.788413451602061], [4.159699560332314e-16, -0.25772285300386016, 0.8169666453154578], [2.3369723287643667e-16, -0.25772286385335375, 1.0051394565869542], [3.0660632213915455e-16, -0.5175967243221771, 0.9700095748745576], [1.9724268824507832e-16, -0.7598645387257426, 0.8696589799522003], [1.2433359898236044e-16, -0.9684637228947344, 0.7107409257907973], [2.5192450519211666e-16, -1.1273817907770178, 0.5021417164671588], [-6.70527603322735e-17, -1.227732377681216, 0.25987394921339635], [7.253037477821286e-17, -1.2628622650436863, 3.8189854665677087e-17], [-3.059821570091466e-17, -1.227732377681216, -0.2598739492133965], [3.319723740396332e-17, -1.1273817907770178, -0.5021417164671585], [8.78790543510016e-17, -0.9684637228947344, -0.7107409257907967], [5.1424509719642767e-17, -0.7598645387257421, -0.8696589799522013], [2.3369723287643667e-16, -0.5175967243221767, -0.9700095748745576], [1.6078814361371926e-16, -0.2577228638533534, -1.0051394565869536], [8.78790543510016e-17, -0.2577228530038599, -0.8169666453154578], [1.2433359898236044e-16, -0.4689455590682551, -0.7884134516020602], [1.6078814361371926e-16, -0.6658582583998094, -0.7068495568092831], [5.1424509719642767e-17, -0.8354054536564309, -0.5776826549057854], [2.3369723287643667e-16, -0.9645723667121137, -0.4081354392037349], [5.856328930444195e-18, -1.0461362549878177, -0.2112227781950388], [-3.6833259115863677e-17, -1.0746894532935332, 3.16613479828425e-17]])
    
    elif type == "cylinder":
        ctrl = cmds.curve(n=name, d=1, p=[[0.17451487367830015, -0.00864386751869475, -1.0], [0.17451487367830013, -0.26746291262121635, -0.9659258262890686], [0.17451487367830032, -0.508643867518696, -0.8660254037844388], [0.17451487367830018, -0.7157506487052431, -0.7071067811865475], [0.17451487367830013, -0.8746692713031344, -0.4999999999999996], [0.17451487367830018, -0.9745696938077639, -0.2588190451025202], [0.17451487367830018, -1.0086438675186942, 7.355227538141662e-16], [0.17451487367829993, -0.9745696938077635, 0.25881904510252157], [0.17451487367830013, -0.8746692713031333, 0.5000000000000008], [0.17451487367830001, -0.7157506487052421, 0.7071067811865481], [0.1745148736783, -0.5086438675186938, 0.8660254037844393], [0.17451487367830004, -0.26746291262121463, 0.9659258262890688], [0.1745148736783002, -0.008643867518694028, 1.0000000000000004], [0.17451487367830018, 0.25017517758382685, 0.9659258262890684], [0.17451487367830001, 0.4913561324813061, 0.8660254037844387], [0.1745148736783002, 0.6984629136678532, 0.7071067811865475], [0.1745148736782997, 0.8573815362657443, 0.4999999999999999], [0.17451487367830032, 0.957281958770374, 0.25881904510252046], [0.17451487367830004, 0.9913561324813055, -2.983724378680108e-16], [0.17451487367830035, 0.9572819587703737, -0.25881904510252096], [0.1745148736782999, 0.8573815362657441, -0.5000000000000002], [0.17451487367830035, 0.6984629136678531, -0.7071067811865477], [0.17451487367830007, 0.49135613248130544, -0.8660254037844388], [0.17451487367830018, 0.2501751775838262, -0.9659258262890683], [0.17451487367830015, -0.00864386751869475, -1.0], [-0.1745148736782994, -0.008643867518694611, -1.0], [-0.1745148736782994, -0.2674629126212162, -0.9659258262890686], [-0.17451487367829935, -0.5086438675186956, -0.8660254037844388], [-0.17451487367829963, -0.7157506487052435, -0.7071067811865475], [-0.1745148736782992, -0.8746692713031343, -0.4999999999999996], [-0.17451487367829951, -0.974569693807764, -0.2588190451025202], [-0.17451487367829943, -1.0086438675186953, 7.355227538141662e-16], [0.17451487367830018, -1.0086438675186942, 7.355227538141662e-16], [-0.17451487367829943, -1.0086438675186953, 7.355227538141662e-16], [-0.1745148736782997, -0.9745696938077638, 0.25881904510252157], [-0.17451487367829938, -0.8746692713031334, 0.5000000000000008], [-0.1745148736782996, -0.7157506487052424, 0.7071067811865481], [-0.17451487367829935, -0.5086438675186941, 0.8660254037844393], [-0.1745148736782998, -0.26746291262121497, 0.9659258262890688], [-0.17451487367829963, -0.00864386751869407, 1.0000000000000004], [0.1745148736783002, -0.008643867518694028, 1.0000000000000004], [-0.17451487367829963, -0.00864386751869407, 1.0000000000000004], [-0.17451487367829963, 0.25017517758382696, 0.9659258262890684], [-0.17451487367829954, 0.49135613248130594, 0.8660254037844387], [-0.17451487367829946, 0.698462913667853, 0.7071067811865475], [-0.17451487367829943, 0.8573815362657441, 0.4999999999999999], [-0.17451487367829926, 0.9572819587703739, 0.25881904510252046], [-0.17451487367829965, 0.9913561324813057, -2.983724378680108e-16], [0.17451487367830004, 0.9913561324813055, -2.983724378680108e-16], [-0.17451487367829965, 0.9913561324813057, -2.983724378680108e-16], [-0.1745148736782993, 0.9572819587703736, -0.25881904510252096], [-0.17451487367829943, 0.8573815362657441, -0.5000000000000002], [-0.17451487367829954, 0.6984629136678527, -0.7071067811865477], [-0.17451487367829904, 0.4913561324813052, -0.8660254037844388], [-0.1745148736782993, 0.25017517758382596, -0.9659258262890683], [-0.1745148736782994, -0.008643867518694611, -1.0]])

    else:
        cmds.warning("createControl doesn't know shape - '%s'"%type)

    #rotate to axis
    cmds.select("{0}.cv[*]".format(ctrl))
    cmds.rotate(rot[0], rot[1], rot[2], r=True)
    cmds.select(cl=True)
    shapes = cmds.listRelatives(ctrl, shapes=True)
    for shape in shapes:
        cmds.setAttr("%s.overrideEnabled"%shape, 1)
        cmds.setAttr("%s.overrideColor"%shape, colors[color])
        cmds.rename(shape, "{0}Shape".format(ctrl))

    cmds.select(ctrl, r=True)
    return(ctrl)


def createMessage(host="none", attr="none", target="none", *args):
    """creates a message attr on object with target as value. Args are: 'host'-some object to hold the message attr, 'attr'-the name of the message attribute to create, and 'target'-the host to be the value of the message attr"""
    cmds.addAttr(host, at='message', ln=attr)
    cmds.connectAttr("%s.message"%target, "%s.%s"%(host, attr))
    return("%s.%s"%(host, attr))


def getVertUV(vertsList = [], *args):
    """use a vert input to get the UV value"""
    uvVals = []
    for v in vertsList:
        uv = cmds.polyListComponentConversion(v, fv=True, tuv=True)
        uvVal = cmds.polyEditUV(uv, q=True, u=True, v=True)
        uvVals.append(uvVal)
    return(uvVals)


def alignToUV(targetObj="none", sourceObj="none", sourceU=0.0, sourceV=0.0, mainAxis="+z", secAxis="+x", UorV="v"):
    """
    inputs should be 1. targetObj 2. sourceObj 3. sourceU 4. sourceV 5. mainAxis(lowerCase, + or -, i.e."-x" 8. secAxis (lowcase, + or -) 7, UorV ("u" or "v" for the direction along surface for the sec axis)
"""

    axisDict = {"+x":(1,0,0), "+y":(0,1,0), "+z":(0,0,1), "-x":(-1,0,0), "-y":(0,-1,0), "-z":(0,0,-1)}

    #Does this create a new node? no To create a node, use the flag "ch=True". That creates a pointOnSurface node
    pos = cmds.pointOnSurface(sourceObj, u=sourceU, v=sourceV, position=True)
    posVec = om.MVector(pos[0], pos[1], pos[2])
    cmds.xform(targetObj, ws=True, t=pos)

    #get normal, tanU and tanV at selected UV position on source surface
    tanV = cmds.pointOnSurface(sourceObj, u=sourceU, v=sourceV, tv=True)
    tanU = cmds.pointOnSurface(sourceObj, u=sourceU, v=sourceV, tu=True)
    norm = cmds.pointOnSurface(sourceObj, u=sourceU, v=sourceV, nn=True)

    #decide where up axis is on normal constraint, u or v tangent
    if UorV == "v":
        wup = tanV
    elif UorV == "u":
        wup = tanU

    #create normal constraint
    nc = cmds.normalConstraint(sourceObj, targetObj, aimVector=axisDict[mainAxis], upVector=axisDict[secAxis], worldUpVector=(wup))
    cmds.delete(nc) #delete constraint


def groupOrient(target='none',orig='none', group="GRP"):
    """
    groups the second object and snaps the group to the second (point and orient). The group arg is to name the suffix you want the group to have (default is '_GRP')
    Arguments: target (to be constrained to), orig (obj to move), group (suffix for group)
    """
    if (target == "none"):
        sel = getTwoSelection()
        target = sel[0]
        orig = sel[1]

    cmds.select(orig)
    grpName = "%s_%s"%(orig,group)
    cmds.group(name=grpName)
    pc = cmds.pointConstraint(target, grpName)
    oc = cmds.orientConstraint(target, grpName)
    cmds.delete(pc)
    cmds.delete(oc)
    cmds.select(clear=True)

    return(grpName)


def stripToRotate(first="none", *args):
    attrs = ["tx", "ty", "tz", "sx", "sy", "sz", "visibility"]
    objs = []
    if first=="none":
        objs = getSelection()
    else:
        objs.append(first)
        if args:
            for each in args:
                objs.append(each)
##    print(objs)
    for me in objs:
        for attr in attrs:
            objAttr = me + "." + attr
            cmds.setAttr(objAttr, lock=True, k=False)


def stripToTranslate(first="none", *args):
    """strips for all selected or entered as args, sets all attrs but translate to locked and hidden"""
    attrs = ["rx", "ry", "rz", "sx", "sy", "sz", "visibility"]
    objs = []
    if first=="none":
        objs = getSelection()
    else:
        objs.append(first)
        if args:
            for each in args:
                objs.append(each)
##    print(objs)
    for me in objs:
        for attr in attrs:
            objAttr = me + "." + attr
            cmds.setAttr(objAttr, lock=True, k=False)


def stripToRotateTranslate(first="none", *args):
    """strips for all selected or entered as args, sets all attrs but translate to locked and hidden"""
    attrs = ["sx", "sy", "sz", "visibility"]
    objs = []
    if first=="none":
        objs = getSelection()
    else:
        objs.append(first)
        if args:
            for each in args:
                objs.append(each)
##    print(objs)
    for me in objs:
        for attr in attrs:
            objAttr = me + "." + attr
            cmds.setAttr(objAttr, lock=True, k=False)


def lockTranslate(first="none", *args):
    attrs = ["tx", "ty", "tz"]
    objs = []
    if first=="none":
        objs = getSelection()
    else:
        objs.append(first)
        if args:
            for each in args:
                objs.append(each)
    for me in objs:
        for attr in attrs:
            objAttr = me + "." + attr
            cmds.setAttr(objAttr, lock=True)


def stripTransforms(first="none", *args):
    """locks and hides all transforms from channel box. can call multiple objs as arguments or use selection of objects"""
    attrs = ["rx", "ry", "rz", "tx", "ty", "tz", "sx", "sy", "sz", "visibility"]
    objs = []
    if first=="none":
        objs = getSelection()
    else:
        objs.append(first)
        if args:
            for each in args:
                objs.append(each)
    print(objs)
    for me in objs:
        for attr in attrs:
            objAttr = me + "." + attr
            cmds.setAttr(objAttr, lock=True, k=False)


def restoreTransforms(first="none", *args):
    """restores all the default locked and hidden channels back to the channels box"""
    attrs = ["tx", "ty", "tz", "rx", "ry", "rz", "sx", "sy", "sz", "visibility"]
    objs = []
    if first=="none":
        objs = getSelection()
    else:
        objs.append(first)
        for each in args:
            objs.append(each)
    print(objs)
    for me in objs:
        for attr in attrs:
            objAttr = me + "." + attr
            cmds.setAttr(objAttr, lock=False, k=True)


def createAdd(name, input1, input2):
    """creates an addDoubleLinear node with name, object.attr, object.attr as args"""
    adl = cmds.shadingNode("addDoubleLinear", asUtility=True, name=name)
    cmds.connectAttr(input1, "%s.input1"%adl)
    cmds.connectAttr(input2, "%s.input2"%adl)
    return(adl)


def blendRotation(blend="none", sourceA="none", sourceB="none", target="none", sourceValue="none"):
    #add input and *args?
    """name is first arg, then three objects. Blends rotation from first two selected into third selected. SourceValue (last input) is for the driving obj.attr. First source is active at '1', second at '2'"""
    if blend == "none":
        blend = "blendColors"
    if sourceA == "none":
        sel = getSelection()
        if len(sel) != 3:
            cmds.error("Error: blendRotation, select three transforms")
            #inert some kind of break here
        sourceA = sel[0]
        sourceB = sel[1]
        target = sel[2]
    blend = cmds.shadingNode("blendColors", asUtility=True, name=blend)
    sourceAOut = sourceA + ".rotate"
    sourceBOut = sourceB + ".rotate"
    targetIn = target + ".rotate"
    blend1 = blend + ".color1"
    blend2 = blend + ".color2"
    blendOut = blend + ".output"
    cmds.connectAttr(sourceAOut, blend1)
    cmds.connectAttr(sourceBOut, blend2)
    cmds.connectAttr(blendOut, targetIn)
    if not sourceValue == "none":
        cmds.connectAttr(sourceValue, "%s.blender"%blend)

    return(blend)

def blendTranslate(blend="none", sourceA="none", sourceB="none", target="none", sourceValue="none"):
    """name is first arg, then three objects. Blends translation from first two selected into third selected. SourceValue (last input) is for the driving obj.attr. First source is active at '1', second at '2'"""
    #add input and *args
    if blend == "none":
        blend = "blendColors"
    if sourceA == "none":
        sel = getSelection()
        if len(sel) != 3:
            cmds.error("Error: blendRotation, select three transforms")
            #inert some kind of break here
        sourceA = sel[0]
        sourceB = sel[1]
        target = sel[2]
    blend = cmds.shadingNode("blendColors", asUtility=True, name=blend)
    sourceAOut = sourceA + ".translate"
    sourceBOut = sourceB + ".translate"
    targetIn = target + ".translate"
    blend1 = blend + ".color1"
    blend2 = blend + ".color2"
    blendOut = blend + ".output"
    cmds.connectAttr(sourceAOut, blend1)
    cmds.connectAttr(sourceBOut, blend2)
    cmds.connectAttr(blendOut, targetIn)
    if not sourceValue == "none":
        cmds.connectAttr(sourceValue, "%s.blender"%blend)

    return(blend)

def blendScale(blend="none", sourceA="none", sourceB="none", target="none", sourceValue="none"):
    """name is first arg, then three objects. Blends translation from first two selected into third selected. SourceValue (last input) is for the driving obj.attr. First source is active at '1', second at '2'"""
    #add input and *args
    if blend == "none":
        blend = "blendColors"
    if sourceA == "none":
        sel = getSelection()
        if len(sel) != 3:
            cmds.error("Error: blendRotation, select three transforms")
            #inert some kind of break here
        sourceA = sel[0]
        sourceB = sel[1]
        target = sel[2]
    blend = cmds.shadingNode("blendColors", asUtility=True, name=blend)
    sourceAOut = sourceA + ".scale"
    sourceBOut = sourceB + ".scale"
    targetIn = target + ".scale"
    blend1 = blend + ".color1"
    blend2 = blend + ".color2"
    blendOut = blend + ".output"
    cmds.connectAttr(sourceAOut, blend1)
    cmds.connectAttr(sourceBOut, blend2)
    cmds.connectAttr(blendOut, targetIn)
    if not sourceValue == "none":
        cmds.connectAttr(sourceValue, "%s.blender"%blend)

    return(blend)


# def colorControl(color="none", *args):
#   """enter a color (red, blue, green, yellow, dkRed, dkBlue, dkGreen, dkYellow, pink, ltBlue, ltGreen, ltYellow, black, purple), then objs or selection"""
#   if color == "none":
#       cmds.error("must choose a color to use 'colorControl'")
#   #create dictionary
#   colors = {"red":13}
#   if args == ():
#       args = getSelection()
#   for obj in args:
#       #get shape node
#       #check to make sure there is a shape node
#       #set coloroverride to 1
#       #set color to color value of dict
#       pass


# def standInGeo():
# ##  check that there is a next joint
# ##  measure distance to next joint?
# ##    create geo that is scaled to that measurement
# ##    snap the geo to the joint
#   pass

def addGroupAbove(obj="none", suff="none", *args):
    """name of existing obj, new group suffix. New group will be oriented to the object BELOW it"""
    #FIX THE OBJ, SUFIX TO BE EITHER SELECTED OR ENTERED
    sel = cmds.ls(sl=True, type = "transform")
    for obj in sel:
        suff = "_new"
        name = obj + suff + "_GRP"
        #get worldspace location of existing obj
        loc = cmds.xform(obj, q=True, ws=True, rp=True)
        #create new group, name it, move it to new postion in ws and Orient it
        grp = cmds.group(empty=True, name=name)
        cmds.move(loc[0], loc[1], loc[2], grp, ws=True)
        oc = cmds.orientConstraint(obj, grp)
        cmds.delete(oc)
        #check if there's a parent to the old group
        par = cmds.listRelatives(obj, p=True)
        print(par)
        if par:
            cmds.parent(grp, par)
        cmds.parent(obj, grp)

def addGroupBelow(*args):
############----------fix lots of stuff here, but basic idea works  
    sel = cmds.ls(sl=True)

    for obj in sel:
        pos = cmds.xform(obj, ws=True, q=True, rp=True)
        rot = cmds.xform(obj, ws=True, q=True, ro=True)
        
        children = cmds.listRelatives(obj, children=True)
        
        grp = cmds.group(em=True, name=obj.replace("Auto", "Manual"))
        
        cmds.xform(grp, ws=True, t=pos)
        cmds.xform(grp, ws=True, ro=rot)
        
        cmds.parent(grp, obj)
        for child in children:
            cmds.parent(child, grp) 
    

def reverseSetup(inAttr, strAttr, revAttr, rName, *args):
    """
    4 arguments, the (node.attr) that enters the rev, straight conn,
    the reversed, then the reverse node name
    """
    cmds.shadingNode("reverse", asUtility=True, name=rName)
    rIn = rName + ".input"
    rOut = rName + ".output"
    cmds.connectAttr(inAttr, strAttr)
    cmds.connectAttr(inAttr, rIn)
    cmds.connectAttr(rOut, revAttr)
    cmds.select(cl=True)

# def addExpression():
# ##    expr = "code goes here"
# ##    obj = []
# ##    cmds.expression(object=obj, string=expr)
#   pass

# def snapToVertex():
# ##    get the selection of vertex (flatten it?)
# ##    get the worldspace location of the vertex
# ##    move the obj to the location of the vertex
#   pass

# def nameTypeSelection():
# ##    get wildcard selection and type selection
# ##    loop selection to select add
#   pass

# def createQSS(name="none", *args):
# ##    if name == "none":
# ##        cmds.error("you must enter a name and a selection (either manual or as arguments")
# ##    else:
# ##        for arg in args:

# ##    get the objects (*args)
# ##    create QSS using either selection or *args
#   pass

def measureDistance(mName="none", *args):
    """first the name of the measure node, then the 2 objects ORRRR select the two objects and run (will give name 'distanceBetween'"""
    objs = []
    if mName == "none":
        mName = "distanceBetween"
        objs = getTwoSelection()
    else:
        for each in args:
            objs.append(each)
    #add check for 2 selectiont
    if len(objs) != 2:
        cmds.error("you must enter either a measure name and 2 objects OR no arguments and manually select 2 objs")
    dist = cmds.shadingNode("distanceBetween", asUtility=True, name=mName)
    objA = objs[0]
    objB = objs[1]
    objAMatrix = objA + ".worldMatrix"
    objBMatrix = objB + ".worldMatrix"
    objAPoint = objA + ".rotatePivot"
    objBPoint = objB + ".rotatePivot"
    distPoint1 = dist + ".point1"
    distPoint2 = dist + ".point2"
    distMatrix1 = dist + ".inMatrix1"
    distMatrix2 = dist + ".inMatrix2"
    cmds.connectAttr(objAPoint, distPoint1)
    cmds.connectAttr(objBPoint, distPoint2)
    cmds.connectAttr(objAMatrix, distMatrix1)
    cmds.connectAttr(objBMatrix, distMatrix2)
    cmds.select(clear=True)
    return(dist)

def scaleStretchIK(limbName="none", ikTop="none", ikMid="none", ikLow="none", jntMeasure="none", IKMeasure="none", IKCtrl="none", axis="none", *args):
    """creates a stretch setup for 3 joint IK chain. Inputs (strings) are the limbName, 3 ik joints (top to bottom), the measure input for the whole chain (add up from measure joints), the measure for the ikCtrl, the ik handle or ctrl (which must have 'scaleMin', 'upScale' and 'lowScale' attrs, the axis letter. Returns . . . """

    ratioMult = cmds.shadingNode("multiplyDivide", asUtility=True, n="%s_stretchRatioMult"%limbName)
    cmds.setAttr(ratioMult + ".operation", 2)
    cmds.connectAttr(jntMeasure, "%s.input2X"%ratioMult)
    cmds.connectAttr(IKMeasure, "%s.input1X"%ratioMult)

    #could put this default stuff (next two paragraphs) after the conditional and use another conditional so that minScale is bundled up in "autostretch"
    #create default setting of 1 when autostretch is off
    defaultMult = cmds.shadingNode("multiplyDivide", asUtility=True, n="%s_stretchDefaultMult"%limbName)
    cmds.setAttr("%s.input1X"%defaultMult, 1)

    #create blend node to blend ratio mult and default values, based on blender attr of ikctrl.autoStretch
    defaultBlend = cmds.shadingNode("blendColors", asUtility=True, n="%s_stretchBlend"%limbName)
    cmds.connectAttr("%s.outputX"%defaultMult, "%s.color2R"%defaultBlend)
    cmds.connectAttr("%s.outputX"%ratioMult, "%s.color1R"%defaultBlend)
    cmds.connectAttr("%s.autoStretch"%IKCtrl, "%s.blender"%defaultBlend)

    #blend goes into condition node - firstTerm, secondTerm=ikctrl scaleMin value, operation=2(greaterthan), colorIfTrue is blend, colorIfFalse is scaleMin attr
    conditional = cmds.shadingNode("condition", asUtility=True, n="%s_upStretchCondition"%limbName)
    cmds.setAttr("%s.operation"%conditional, 2)
    cmds.connectAttr("%s.outputR"%defaultBlend, "%s.firstTerm"%conditional)
    cmds.connectAttr("%s.scaleMin"%IKCtrl, "%s.secondTerm"%conditional)
    cmds.connectAttr("%s.outputR"%defaultBlend, "%s.colorIfTrueR"%conditional)
    cmds.connectAttr("%s.scaleMin"%IKCtrl, "%s.colorIfFalseR"%conditional)

    #factor in the upScale/lowScale attrs
    upScaleMult = cmds.shadingNode('multiplyDivide', asUtility=True, n="%s_upScaleMult"%limbName)
    cmds.connectAttr("%s.outColorR"%conditional, "%s.input1X"%upScaleMult)
    cmds.connectAttr("%s.upScale"%IKCtrl, "%s.input2X"%upScaleMult)
    loScaleMult = cmds.shadingNode('multiplyDivide', asUtility=True, n="%s_loScaleMult"%limbName)
    cmds.connectAttr("%s.outColorR"%conditional, "%s.input1X"%loScaleMult)
    cmds.connectAttr("%s.lowScale"%IKCtrl, "%s.input2X"%loScaleMult)

    #hook up the scales of the joints
    cmds.connectAttr("%s.outputX"%upScaleMult, "%s.s%s"%(ikTop, axis))
    cmds.connectAttr("%s.outputX"%loScaleMult, "%s.s%s"%(ikMid, axis))

    return(ratioMult, defaultMult, defaultBlend, conditional, upScaleMult, loScaleMult)

def translateStretchIK(limbName="none", ikTop="none", ikMid="none", ikLow="none", jntMeasure="none", IKMeasure="none", IKCtrl="none", axis="none", posNeg="none", *args):
    """creates a stretch setup for 3 joint IK chain. Inputs (strings) are the limbName, 3 ik joints (top to bottom), the measure input for the whole chain (add up from measure joints?), the measure for the ikCtrl, the ik handle or ctrl (which must have 'scaleMin' attr, the axis letter, and PosNeg, which is +1 or -1 (minus for things in negative direction/mirror). Returns . . . """
    #set up the ratio of ctrl to measure
    ratioMult = cmds.shadingNode("multiplyDivide", asUtility=True, n="%s_stretchRatioMult"%limbName)
    cmds.setAttr(ratioMult + ".operation", 2)
    cmds.connectAttr(jntMeasure, "%s.input2X"%ratioMult)
    cmds.connectAttr(IKMeasure, "%s.input1X"%ratioMult)

    #create default setting of 1 when autostretch is off
    default = cmds.shadingNode("multiplyDivide", asUtility=True, n="%s_stretchDefaultMult"%limbName)
    cmds.setAttr("%s.input1X"%default, 1)

    #create blend node to blend ratio mult and default values, based on blender attr of ikctrl.autoStretch
    defaultBlend = cmds.shadingNode("blendColors", asUtility=True, n="%s_stretchBlend")
    cmds.connectAttr("%s.outputX"%default, "%s.color2R"%defaultBlend)
    cmds.connectAttr("%s.outputX"%ratioMult, "%s.color1R"%defaultBlend)
    cmds.connectAttr("%s.autoStretch"%IKCtrl, "%s.blender"%defaultBlend)

    #get the top joint length
    tAxis = "t%s"%axis
    topLength = cmds.getAttr("%s.%s"%(ikMid, tAxis))
    #do I need measure joints?

    #create length factor for top
    topFactorMult = cmds.shadingNode("multiplyDivide", asUtility=True, n="%s_stretchFactorTopMult"%limbName)
    cmds.setAttr("%s.input1X"%topFactorMult, topLength)
    cmds.connectAttr("%s.outputR"%defaultBlend,"%s.input2X"%topFactorMult)

    #set up for clamp
    topClamp = cmds.shadingNode("clamp", asUtility=True, n="%s_stretchTopClamp"%limbName)
    cmds.connectAttr("%s.outputX"%topFactorMult, "%s.inputR"%topClamp)

    #create min, max, connect to clamp
    topMin = cmds.shadingNode("multiplyDivide", asUtility=True, n="%s_topMinMult"%limbName)
    topMax = cmds.shadingNode("multiplyDivide", asUtility=True, n="%s_topMaxMult"%limbName)
    if posNeg == 1:
        cmds.setAttr("%s.input1X"%topMin, topLength)
        cmds.connectAttr("%s.scaleMin"%IKCtrl, "%s.input2X"%topMin)
        cmds.setAttr("%s.input1X"%topMax, topLength)
        cmds.setAttr("%s.input2X"%topMax, 4)
        cmds.connectAttr("%s.outputX"%topMin, "%s.minR"%topClamp)
        cmds.connectAttr("%s.outputX"%topMax, "%s.maxR"%topClamp)
    if posNeg == -1:
        cmds.setAttr("%s.input1X"%topMax, topLength)
        cmds.connectAttr("%s.scaleMin"%IKCtrl, "%s.input2X"%topMax)
        cmds.setAttr("%s.input1X"%topMin, topLength)
        cmds.setAttr("%s.input2X"%topMin, 4)
        cmds.connectAttr("%s.outputX"%topMin, "%s.minR"%topClamp)
        cmds.connectAttr("%s.outputX"%topMax, "%s.maxR"%topClamp)

    #connect to joints
    cmds.connectAttr("%s.outputR"%topClamp, "%s.%s"%(ikMid, tAxis))

    #do lower half
    #get the low joint length
    tAxis = "t%s"%axis
    lowLength = cmds.getAttr("%s.%s"%(ikLow, tAxis))
    #do I need measure joints?

    #create length factor for low
    lowFactorMult = cmds.shadingNode("multiplyDivide", asUtility=True, n="%s_stretchFactorLowMult"%limbName)
    cmds.setAttr("%s.input1X"%lowFactorMult, lowLength)
    cmds.connectAttr("%s.outputR"%defaultBlend,"%s.input2X"%lowFactorMult)

    #set up for clamp
    lowClamp = cmds.shadingNode("clamp", asUtility=True, n="%s_stretchlowClamp"%limbName)
    cmds.connectAttr("%s.outputX"%lowFactorMult, "%s.inputR"%lowClamp)

    #create min, max, connect to clamp
    lowMin = cmds.shadingNode("multiplyDivide", asUtility=True, n="%s_lowMinMult"%limbName)
    lowMax = cmds.shadingNode("multiplyDivide", asUtility=True, n="%s_lowMaxMult"%limbName)
    if posNeg == 1:
        cmds.setAttr("%s.input1X"%lowMin, lowLength)
        cmds.connectAttr("%s.scaleMin"%IKCtrl, "%s.input2X"%lowMin)
        cmds.setAttr("%s.input1X"%lowMax, (lowLength*posNeg))
        cmds.setAttr("%s.input2X"%lowMax, 4)
        cmds.connectAttr("%s.outputX"%lowMin, "%s.minR"%lowClamp)
        cmds.connectAttr("%s.outputX"%lowMax, "%s.maxR"%lowClamp)
    if posNeg == (-1):
        cmds.setAttr("%s.input1X"%lowMax, lowLength)
        cmds.connectAttr("%s.scaleMin"%IKCtrl, "%s.input2X"%lowMax)
        cmds.setAttr("%s.input1X"%lowMin, lowLength)
        cmds.setAttr("%s.input2X"%lowMin, 4)
        cmds.connectAttr("%s.outputX"%lowMin, "%s.minR"%lowClamp)
        cmds.connectAttr("%s.outputX"%lowMax, "%s.maxR"%lowClamp)
    #connect to joints
    cmds.connectAttr("%s.outputR"%lowClamp, "%s.%s"%(ikLow, tAxis))


    return(ratioMult, topFactorMult, lowFactorMult, topMin, topMax, lowMin, lowMax, topClamp, lowClamp)

# def curveInfo():
#   pass

# def attachToCurve():
#   pass

# def jointCleanUp():
#   pass
##    OR select top joint, unparent child, zero rots, parent back (for multiple children)?
##    zero rotations
##    parent child back to parent
##    orientJoints

def makePlane(*args):
    points = []
    cmds.polyCreateFacetCtx(pc=False)
    sel = cmds.ls(sl=True, type="transform")
    for obj in sel:
        loc = cmds.pointPosition((obj + ".rotatePivot"), world=True)
        points.append(loc)
        poly = cmds.polyCreateFacet(p=points)
##    try to figure out if theyre planar or not, give warning?


def parentCheck(obj):
    """ checks whether there's a parent and if so returns it (otherwise returns None)"""
    if obj:
        plist = cmds.listRelatives(obj, p=True)
        if plist:
            return(plist)[0]
    return(None)

def isType(obj, typeCheck, *args):
    """
    returns boolean
    give an object and type of object and this will look at a) the node itself and b) if node is transform, will look at shape node
    """
    if cmds.objExists(obj):
        tempType = cmds.objectType(obj)
        if typeCheck == "transform":
            if tempType == "transform":
                return (True)
            else:
                return (False)

        if not tempType == "transform":
            if tempType == typeCheck:
                return True
        else:
            shp = cmds.listRelatives(obj, s=True)
            if shp:
                tempType = cmds.objectType(shp[0])

        if tempType == typeCheck:
            return True

        return False
    return False


def snapTo(target, obj):

    pos = cmds.xform(target, q=True, ws=True, rp=True)
    rot = cmds.xform(target, q=True, ws=True, ro=True)

    cmds.xform(obj, ws=True, t=pos)
    cmds.xform(obj, ws=True, ro=rot)

def swapDupe(obj, target, delete = True, name="", *args):
    """
    replaces an target with a duplicate of the obj
    select the object you want to duplicate, then the target(s), delete bool, name optional
    [obj] is the object to duplicate
    [target] is the target to match and delete(?)
    [delete] is bool to tell whether to delete the target or not
    [name] is string to rename to
    """

    if not name:
        name = obj

    # get pos, rot, scale of target
    pos = cmds.xform(target, q=True, ws=True, rp=True)
    rot = cmds.xform(target, q=True, ws=True, ro=True)
    scl = cmds.getAttr("{0}.scale".format(target))

    # duplicate the object and rename to name, if no name just use unique names
    dupe = cmds.duplicate(obj, name=name, returnRootsOnly=True, renameChildren=True)
    cmds.xform(dupe, ws=True, t=pos)
    cmds.xform(dupe, ws=True, ro=rot)
    cmds.xform(dupe, ws=True, s=scl[0])

    parent = cmds.listRelatives(target, parent=True)
    if parent:
        cmds.parent(dupe, parent[0])

    if delete:
        cmds.delete(target)

    return(dupe[0])

def positionsAlongCurve(crv="", numPts = 3, *args):
    """
    returns list of numPts evenly distributed world positions along given nurbs crv
    """
    if not crv:
        return

    if isType(crv, "nurbsCurve"):
        posList = []
        shp = cmds.listRelatives(crv, s=True)[0]
        poc = cmds.shadingNode("pointOnCurveInfo", asUtility=True, name="tmpPOCInfo")
        cmds.connectAttr("{}.local".format(shp), "{}.inputCurve".format(poc))
        cmds.setAttr("{}.turnOnPercentage".format(poc), 1)
        lineLen = cmds.arclen(crv, ch=False)
        dist = float(numPts)/lineLen

        for x in range(0, numPts+1):
            perc = 1.0/numPts
            cmds.setAttr("{}.parameter".format(poc),x*perc)
            print x*perc
            pos = cmds.getAttr("{}.position".format(poc))[0]
            posList.append(pos)
    
        cmds.delete(poc)
        return(posList)


def rebuildCurve(curve="", num=5, keep=False, ch=False, name="", *args):
    """
    rebuilds curve (checks validity, min cvs, keep/history, etc)
    
    Args:
        curve (string): a valid nurbs curve
        num (int):  int number of pts
        keep (bool):    whether to keep original
        ch (bool):  whether to keep history
        name (string):  name of new curve (left blank will try to keep orig name)

    Returns:
        string: the name of the created curves (could be same as original!)
    """

    newCurve = ""
    if curve:
        if isType(curve, "nurbsCurve"):
            if not name:
                name = curve
            if not keep or not ch:
                ch = False
            if num < 3:
                num = 3

            newCurve = cmds.rebuildCurve(curve, rebuildType = 0, spans = num, keepRange = 0, replaceOriginal=not keep, name = name, ch=ch)[0]

    return newCurve


def doubleProxyCtrlGrp(ctrl = "", *args):
    """
    creates a pair of groups parent constrained to selected ctrl (and it's group). 
    Basically is proxy to switch spaces (from rig part space to world space) for direct connections.
    ctrl should be located in place with a group above (group frozen)
    Args:
        ctrl (string): the name of the ctrl(transform) to create the proxy for. Assumes a group above (group freeze)
    Returns:
        string, string: returns the names of the created ctrl group and the created parent group
    """
    # grab the ctrl (must have group above)?
    ctrlParent = parentCheck(ctrl)
    if not ctrlParent:
        cmds.error("doubleProxyGrp: don't have a parent group on the ctrl!")
        return
        
    # create groups for the proxy
    ctrlGrp = cmds.group(empty=True, n="{0}_proxyCtrl".format(ctrl))
    parGrp = cmds.group(empty=True, n="{0}_proxyGrp".format(ctrlParent))
    # snap groups to the parent and child
    snapTo(ctrlParent, parGrp)
    snapTo(ctrl, ctrlGrp)
    cmds.parent(ctrlGrp, parGrp)
    # constrain groups 
    cmds.parentConstraint(ctrlParent, parGrp, mo=True)
    cmds.parentConstraint(ctrl, ctrlGrp, mo=True)
    # return groups
    return(ctrlGrp, parGrp)


def groupFreeze(obj="", suffix = "GRP", *arg):
    """
    takes an object in worldspace and snaps a group to it, then parents obj to that group
    i.e. zeros out the obj's translates and rotations
    Args:
        obj (string): the object to put under the group (to zero it's transforms)
    Returns:
        string: returns the new group
    """

    grp = cmds.group(empty=True, name="{0}_{1}".format(obj, suffix))
    snapTo(obj, grp)
    cmds.parent(obj, grp)

    return(grp)

def connect_transforms(source="", target = "", t=True, r=True, s=True, *args):
    """
    simple direct connection between transform attrs
    Args:
        source (string): object connections come FROM
        target (string): object connections go to
        t (bool): do translates?
        r (bool): do rotations?
        s (bool): do scales?
    Return: 
        None
    """
    if source and target:
        if t:
            cmds.connectAttr("{0}.t".format(source), "{0}.t".format(target))
        if r:
            cmds.connectAttr("{0}.r".format(source), "{0}.r".format(target))
        if s:
            cmds.connectAttr("{0}.s".format(source), "{0}.s".format(target))


def getFrameRange(*args):
    """
    returns the (min, max) frames of the current playback range in the scene
    """
    min = cmds.playbackOptions(q=True, min=True)
    max = cmds.playbackOptions(q=True, max=True)
    return(min, max)


def insertGroupAbove(obj, *args):
    par = cmds.listRelatives(obj, p=True)
    
    grp = cmds.group(em=True, n="{}_Grp".format(obj))
    
    # grp = nameCheck(grp)

    pos = cmds.xform(obj, q=True, ws=True, rp=True)
    rot = cmds.xform(obj, q=True, ws=True, ro=True)
    
    cmds.xform(grp, ws=True, t=pos)
    cmds.xform(grp, ws=True, ro=rot) 
     
    cmds.parent(obj, grp)
    if par:
        cmds.parent(grp, par[0])

    return(grp)


def boundingBoxCtrl(sel=[], prnt=True, *args):
    """
    creates a control based on the bounding box
    selList (list) - list of obj to use to create control
    prnt (bool) - whether you want to parent the obj to the ctrl
    """

    if not sel:
        sel = cmds.ls(sl=True, type="transform")

    if sel:
        box = cmds.exactWorldBoundingBox(sel) #[xmin, ymin, zmin, xmax, ymax, zmax]
        X = om.MVector(box[0], box[3])
        Y = om.MVector(box[1], box[4])
        Z = om.MVector(box[2], box[5])

        #get bbox lengths along axes
        lenX = (X.y - X.x)
        lenY = (Y.y - Y.x)
        lenZ = (Z.y - Z.x)
        # print lenX, lenY, lenZ

        ctrl = createControl(name="ctrl", type="cube", color="pink")

        cvs ={"xyz":[5, 15],"-xyz":[0, 4],"xy-z":[10, 14],"x-yz":[6, 8],"-x-yz":[3, 7],"-x-y-z":[2, 12],"x-y-z":[9, 13],"-xy-z":[1, 11]}

        for a in cvs["xyz"]:
            cmds.xform("{0}.cv[{1}]".format(ctrl, a), ws=True, t=(X.y, Y.y, Z.y))
        for a in cvs["-xyz"]:
            cmds.xform("{0}.cv[{1}]".format(ctrl, a), ws=True, t=(X.x, Y.y, Z.y))
        for a in cvs["x-yz"]:
            cmds.xform("{0}.cv[{1}]".format(ctrl, a), ws=True, t=(X.y, Y.x, Z.y))
        for a in cvs["-x-yz"]:
            cmds.xform("{0}.cv[{1}]".format(ctrl, a), ws=True, t=(X.x, Y.x, Z.y))
        for a in cvs["xy-z"]:
            cmds.xform("{0}.cv[{1}]".format(ctrl, a), ws=True, t=(X.y, Y.y, Z.x))
        for a in cvs["-xy-z"]:
            cmds.xform("{0}.cv[{1}]".format(ctrl, a), ws=True, t=(X.x, Y.y, Z.x))
        for a in cvs["-x-y-z"]:
            cmds.xform("{0}.cv[{1}]".format(ctrl, a), ws=True, t=(X.x, Y.x, Z.x))
        for a in cvs["x-y-z"]:
            cmds.xform("{0}.cv[{1}]".format(ctrl, a), ws=True, t=(X.y, Y.x, Z.x))
        
        # center pivot on ctrl
        cmds.xform(ctrl, cp=True)

        # get ctrl back to 
        wsPos = cmds.xform(ctrl, ws=True, q=True, rp=True)
        cmds.xform(ctrl, ws=True, t=(-wsPos[0], -wsPos[1], -wsPos[2]))
        cmds.makeIdentity(ctrl, apply=True)
        cmds.xform(ctrl, ws=True, t=wsPos)

        if prnt:
            cmds.parent(sel, ctrl)
        cmds.select(ctrl)
        
        return(ctrl)


def scale_nurbs_control(ctrl=None, x=1, y=1, z=1, *args):
    """
    scales cvs from rotate pivot of obj
    """
    if not ctrl or not isType(ctrl, "nurbsCurve"):
        cmds.warning("zbw_rig.scaleNurbsCtrl: I wsan't passed a nurbsCurve object")
        return()

    piv = cmds.xform(ctrl, q=True, ws=True, rp=True)
    cvs = cmds.ls("{0}.cv[*]".format(ctrl), fl=True)
    cmds.scale(x, y, z, cvs, pivot=piv)


def assignColor(obj=None, clr="yellow", *args):
    
    if cmds.objectType(obj) != "transform":
        return()

    colors = {}
    colors["red"]=13
    colors["blue"]=6
    colors["green"]=14
    colors["darkRed"]=4
    colors["lightRed"]=31
    colors["darkBlue"]=5
    colors["medBlue"]=15
    colors["lightBlue"]=18
    colors["royalBlue"]=29
    colors["darkGreen"]=7
    colors["medGreen"]=27
    colors["lightGreen"]=19
    colors["yellowGreen"]=26
    colors["yellow"]=17
    colors["darkYellow"]=21
    colors["lightYellow"]=22
    colors["purple"]=30
    colors["lightPurple"]=9
    colors["darkPurple"]=8
    colors["black"]=1
    colors["white"]=16
    colors["brown"]=10
    colors["darkBrown"]=11
    colors["lightBrown"]=24
    colors["pink"]=20
    colors["orange"] =12

    shp = cmds.listRelatives(obj, s=True)
    if shp:
        for s in shp:
            cmds.setAttr("{0}.overrideEnabled".format(s), 1)
            cmds.setAttr("{0}.overrideColor".format(s), colors[clr])


def addToLattice(lat, geo, *args):
    """
    lat is lattice, geo is geometry OR a list of geometry
    """

    if isinstance(geo, basestring):
        geo = [geo]

    for g in geo:
        cmds.lattice(lat, e=True, g=g)

def get_selected_channels(full=True, long=True, *args):
    """
    for ONE object selected, return all selected channels from channel box
    :param full: (boolean) return the full name of the object.attr?, if false then returns only the attr names
    ":param long: (boolean) whether we should get the long name of the attr. False will give us "short" names
    :return: list of full obj.channel names selected, or (if not "full") just the channnel names
    """
    cBox = mel.eval('$temp=$gChannelBoxName')

    sel = cmds.ls(sl=True, l=True)
    if len(sel) != 1:
        cmds.warning("You have to select ONE node!")
        return(None)

    obj = sel[0]

    channelsRaw = cmds.channelBox(cBox, q=True, selectedMainAttributes=True, selectedShapeAttributes=True,
                               selectedHistoryAttributes=True,
                               selectedOutputAttributes=True)

    channels = []
    if channelsRaw:
        if long:
            for ch in channelsRaw:
                newC = cmds.attributeQuery(ch, node=obj, longName=True)
                channels.append(newC)
        else:
            for ch in channelsRaw:
                newC = cmds.attributeQuery(ch, node=obj, shortName=True)
                channels.append(newC)
    else: return(None)

    returnList = []
    if channels:
        if full:
            for c in channels:
                full = "{0}.{1}".format(obj, c)
                returnList.append(full)
        else:
            returnList = channels

        return(returnList)
    else:
        cmds.warning("zbw_rig.get_selected_channels: I didn't detect any channels selected!")
        return(None)

def average_vectors(vecList, *args):
    """
    returns the average (x, y, z, . . . ) of a list of given vectors
    :param vecList: a list of vectors
    :param args:
    :return:
    """
    avg = [float(sum(x)/len(x)) for x in zip(*vecList)]
    return(avg)


def integer_test(obj, *args):
    """
    tests whether obj is an integer or not
    :param obj: some value
    :param args:
    :return:  boolean
    """
    try:
        int(obj)
        return True
    except:
        return False


def increment_name(name, *args):
    """
    increments the given name string
    :param name:
    :param args:
    :return:
    """
    split = name.rpartition("_")
    end = split[2]
    isInt = integer_test(end)

    if isInt:
        newNum = int(end) + 1
        newName = "%s%s%02d" % (split[0], split[1], newNum)
    else:
        newName = "{0}_01".format(name)

    return(newName)


def get_soft_selection():
    """
    should be a softSelection already selected (components). This returns list of cmpts and list of weights
    :return: list of components, and list of weights
    """
    # Grab the soft selection
    selection = om.MSelectionList()
    softSelection = om.MRichSelection()
    om.MGlobal.getRichSelection(softSelection)
    softSelection.getSelection(selection)

    dagPath = om.MDagPath()
    component = om.MObject()

    # Filter Defeats the purpose of the else statement
    iter = om.MItSelectionList(selection, om.MFn.kMeshVertComponent)
    elements, weights = [], []
    while not iter.isDone():
        iter.getDagPath(dagPath, component)
        dagPath.pop()  # Grab the parent of the shape node
        node = dagPath.fullPathName()
        fnComp = om.MFnSingleIndexedComponent(component)
        getWeight = lambda i: fnComp.weight(i).influence() if fnComp.hasWeights() else 1.0

        for i in range(fnComp.elementCount()):
            elements.append('%s.vtx[%i]' % (node, fnComp.element(i)))
            weights.append(getWeight(i))
        iter.next()

    return elements, weights


def closest_pt_on_mesh_position(point, mesh, *args):
    """rtrns position of closest pt
        #--------------------
        #inputs and outputs for "closestPointOnMesh":

        #inputs:
        #"mesh"->"inputMesh" (mesh node of transform)
        #"clusPos"->"inPosition"
        #"worldMatrix"(transform of point)->"inputMatrix"

        #outputs:
        #"position"->surfacepoint in space
        #"u"->parameter u
        #"v"->parameter v
        #"normal"->normal vector
        #"closestFaceIndex"->index of closest face
        #"closestVertexIndex"->index of closet vertex
        #---------------------
    """
    if isinstance(point, basestring):
        if isType(point, "transform"):
            # cmds.select(point, r=True)
            ptPos = cmds.xform(point, ws=True, q=True, rp=True)
            name = point
        else:
            cmds.warning("zbw_rig.closest_pt_on_mesh_position: the string you gave me isn't a transform")
            return()
    elif isinstance(point, (list, tuple)):
        if len(point)==3:
            ptPos = point
            name = mesh
        else:
            cmds.warning("zbw_rig.closest_pt_on_mesh_position: there are not the right number of indices in the "
                         "iterable you gave me. Need 3, you gave {0}".format(len(point)))
    else:
        cmds.warning("zbw_rig.closest_pt_on_mesh_position: You didn't give me a name of transform or position(array["
                     "3])")
        return()

    cpomNode = cmds.shadingNode("closestPointOnMesh", asUtility=True, n="{0}_CPOM".format(name))
    cmds.connectAttr("{0}.outMesh".format(mesh), "{0}.inMesh".format(cpomNode))
    cmds.setAttr("{0}.inPosition".format(cpomNode), ptPos[0], ptPos[1], ptPos[2])
    cmds.connectAttr("{0}.worldMatrix".format(mesh), "{0}.inputMatrix".format(cpomNode))

    cpomPos = cmds.getAttr("{0}.position".format(cpomNode))[0]
    cmds.delete(cpomNode)

    return (cpomPos)


def closest_pt_on_mesh_rotation(point, mesh, *args):
# TODO - generalize for various orientations, and various rotation orders
    """
    takes a point (can be name of transform or iterable(3) of rotations and a poly mesh and gives the rotation [rot
    order xyz] (for
    aim along y) align to surface of
    the xform at that point
    """
    if isinstance(point, basestring):
        if isType(point, "transform"):
            cmds.select(point, r=True)
            ptPos = cmds.xform(point, ws=True, q=True, rp=True)
            name = point
        else:
            cmds.warning("zbw_rig.closest_pt_on_mesh_position: the string you gave me isn't a transform")
            return ()
    elif isinstance(point, (list, tuple)):
        if len(point) == 3:
            ptPos = point
            name = mesh
        else:
            cmds.warning("zbw_rig.closest_pt_on_mesh_position: there are not the right number of entries in the "
                         "list you gave me")

    # get the rotations to align to normal at this point
    loc = cmds.spaceLocator()
    CPOMesh = closest_pt_on_mesh_position(point, mesh)
    cmds.xform(loc, ws=True, t=CPOMesh)
    aimVec = (0, 1, 0)
    upVec = (0, 1, 0)
    nc = cmds.normalConstraint(mesh, loc, aim=aimVec, upVector=upVec)
    rot = cmds.xform(loc, ws=True, q=True, ro=True)
    cmds.delete(nc, loc)
    return (rot)


def calibrate_size(xform, scale=0.2, *args):
    """
    will take the bounding box of given transform and return *scale it's longest edge
    or option to do volume and return some portion of that. . .
    just to give scale factor for controls and such
    :param xform:
    :param args:
    :return:
    """
    if not isType(xform, "transform"):
        cmds.warning("zbw_rig.calibrate_size: You didn't pass me a transform ({0})".format(xform))
        return(None)

    box = cmds.exactWorldBoundingBox(xform)  # [xmin, ymin, zmin, xmax, ymax, zmax]
    X = om.MVector(box[0], box[3])
    Y = om.MVector(box[1], box[4])
    Z = om.MVector(box[2], box[5])

    # get bbox lengths along axes
    lenX = (X.y - X.x)
    lenY = (Y.y - Y.x)
    lenZ = (Z.y - Z.x)
    lgst = max([lenX, lenY, lenZ])

    outScale = float(lgst)*float(scale)

    return(outScale)


def average_point_positions(points, *args):
    """
    uses a list of points and gets the average position
    :param points: list of points to average
    :param args:
    :return: a vector of the average position of given elemenets
    """
    positions = []

    for pt in points:
        pos = cmds.pointPosition(pt)
        positions.append(pos)

    avgPos = average_vectors(positions)
    return(avgPos)


def get_deformers(obj, *args):
    """
    gets a list of deformers on the passed obj
    :param obj: string - the transform to get deformers on
    :param args:
    :return:
    """
    history = cmds.listHistory(obj)
    deformerList = []
    if history:
        for node in history:
            types = cmds.nodeType(node, inherited=True)
            if "geometryFilter" in types:
                deformerList.append(types[1])

    return(deformerList)


def bounding_box_center(geo, *args):
    """
    gets center from bounding box
    :param geo: string - the transform to get bbox info from
    :param args:
    :return: vector/list of bounding box center (or None)
    """

    if isType(geo, "transform"):
        box = cmds.exactWorldBoundingBox(geo)  # [xmin, ymin, zmin, xmax, ymax, zmax]
        X = om.MVector(box[0], box[3])
        Y = om.MVector(box[1], box[4])
        Z = om.MVector(box[2], box[5])

        cx = (box[0]+box[3])/2
        cy = (box[1]+box[4])/2
        cz = (box[2]+box[5])/2

        return([cx, cy, cz])

    return(None)


def new_joint_bind_at_center(tform, *args):
    """
    create a new joint at the boudnign box center of pts and bind all pts to 1
    :param tform - string - the geo to bind
    :param args:
    :return: string - skinCluster
    """
    cmds.select(cl=True)
    jnt = cmds.joint(name="{0}_base_JNT".format(tform))
    center = bounding_box_center(tform)
    cmds.xform(jnt, ws=True, t=center)
    skinCl = cmds.skinCluster(jnt, tform, normalizeWeights=1)[0]

    return(jnt, skinCl)


def plugin_load(plugin, *args):
    """
    checks whether plugin is loaded. Loads it if not
    """
    loaded = cmds.pluginInfo(plugin, q=True, loaded=True)
    if not loaded:
        cmds.loadPlugin(plugin)


def align_to_curve(crv=None, obj=None, param=None, *args):
    """
    places the obj on the curve aligned to . . .
    Args:
        obj (string): object to align
        crv: (string): curve TRANSFORM to align to
        param (float): parameter along curve to position and orient to
        *args:

    Returns:
        void

    """
#TODO - check on non-orig geo, check the matrix plugin is loaded
    if not obj and crv and param:
        cmds.warning("zbw_rig.align_to_curve: Didnt' get all the correct params! (obj, crv, param)")
        return()

    if not isType(crv, "nurbsCurve"):
        cmds.warning("zbw_rig.align_to_curve: crv param wasn't a curve!")
        return()

    crvShp = cmds.listRelatives(crv, s=True)[0]
    tempObj = cmds.group(empty=True, name="tempCrvNull")

    poci = cmds.shadingNode("pointOnCurveInfo", asUtility=True, name="tempPOCI")
    cmds.connectAttr("{0}.worldSpace[0]".format(crvShp), "{0}.inputCurve".format(poci))
    cmds.setAttr("{0}.parameter".format(poci), param)
    cmds.connectAttr("{0}.position".format(poci), "{0}.translate".format(tempObj))
    sideVal = cmds.getAttr("{0}.normalizedNormal".format(poci))[0]
    side = om.MVector(sideVal[0], sideVal[1], sideVal[2])
    frontVal = cmds.getAttr("{0}.normalizedTangent".format(poci))[0]
    front = om.MVector(frontVal[0], frontVal[1], frontVal[2])

    up = side ^ front

    mat4 = cmds.shadingNode("fourByFourMatrix", asUtility=True, name="temp4x4")
    decomp = cmds.shadingNode("decomposeMatrix", asUtility=True, name="tempDM")
    yrow = [side[0], side[1], side[2], 0]
    xrow = [front[0], front[1], front[2], 0]
    zrow = [up[0], up[1], up[2], 0]

    for col in range(3):
        cmds.setAttr("{0}.in0{1}".format(mat4, col), xrow[col])
        cmds.setAttr("{0}.in1{1}".format(mat4, col), yrow[col])
        cmds.setAttr("{0}.in2{1}".format(mat4, col), zrow[col])
    cmds.setAttr("{0}.in33".format(mat4), 1)

    cmds.connectAttr("{0}.output".format(mat4), "{0}.inputMatrix".format(decomp))
    cmds.connectAttr("{0}.outputRotate".format(decomp), "{0}.rotate".format(tempObj))
    snapTo(tempObj, obj)

    cmds.delete(tempObj, poci, decomp, mat4)


def get_nonOrig_shapes(*args):
    pass